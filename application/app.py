# app.py
import time
import threading
import queue
import cv2
from flask import Flask, Response, jsonify, request
from monitoring_logic import (
    run_yolo_detection, run_gemini_inference, create_final_summary
)
import config # Ensures config is loaded

app = Flask(__name__)

# --- Global State Management ---
# This state is shared across all web requests and background threads
STATE = {
    "monitoring_active": False,
    "yolo_thread": None,
    "gemini_thread": None,
    "stop_event": None,
    "log_queue": queue.Queue(),
    "frame_lock": threading.Lock(),
    "shared_state": {
        "latest_annotated_frame": None,
        "camera_error": None
    }
}
# Lock to protect access to STATE variables like monitoring_active, threads, etc.
STATE_LOCK = threading.Lock()

# --- API Endpoints ---

@app.route('/start', methods=['POST'])
def start_monitoring():
    with STATE_LOCK:
        if STATE["monitoring_active"]:
            return jsonify({"status": "error", "message": "Monitoring is already active."}), 400
        
        # Reset state
        STATE["monitoring_active"] = True
        STATE["stop_event"] = threading.Event()
        STATE["log_queue"] = queue.Queue() # Clear old logs
        STATE["shared_state"]["camera_error"] = None
        STATE["shared_state"]["latest_annotated_frame"] = None
        
        # Start Threads
        STATE["yolo_thread"] = threading.Thread(
            target=run_yolo_detection,
            args=(STATE["stop_event"], STATE["log_queue"], STATE["frame_lock"], STATE["shared_state"]),
            daemon=True
        )
        STATE["gemini_thread"] = threading.Thread(
            target=run_gemini_inference,
            args=(STATE["stop_event"], STATE["log_queue"], STATE["frame_lock"], STATE["shared_state"]),
            daemon=True
        )
        
        STATE["yolo_thread"].start()
        STATE["gemini_thread"].start()
        
        STATE["log_queue"].put(("toast", "üöÄ Monitoring started..."))
        return jsonify({"status": "started"})

@app.route('/stop', methods=['POST'])
def stop_monitoring():
    summary = "Monitoring was not active."
    with STATE_LOCK:
        if not STATE["monitoring_active"]:
            return jsonify({"status": "error", "message": "Monitoring is not active."}), 400
        
        STATE["log_queue"].put(("toast", "üõë Stopping monitors... Please wait."))
        STATE["stop_event"].set()
        
        if STATE["yolo_thread"]:
            STATE["yolo_thread"].join()
        if STATE["gemini_thread"]:
            STATE["gemini_thread"].join()
            
        STATE["monitoring_active"] = False
        
        # Generate final summary after threads are stopped
        summary = create_final_summary(STATE["log_queue"])
        
    return jsonify({"status": "stopped", "summary": summary})

@app.route('/status', methods=['GET'])
def get_status():
    with STATE_LOCK:
        status = {
            "monitoring_active": STATE["monitoring_active"],
            "camera_error": STATE["shared_state"]["camera_error"]
        }
    return jsonify(status)

@app.route('/get_logs', methods=['GET'])
def get_logs():
    logs = []
    while not STATE["log_queue"].empty():
        try:
            level, message = STATE["log_queue"].get_nowait()
            logs.append({"level": level, "message": message})
        except queue.Empty:
            break
    return jsonify({"logs": logs})

# --- Video Streaming ---

def generate_frames():
    """Generator function to stream video frames."""
    while True:
        with STATE["frame_lock"]:
            if STATE["shared_state"]["latest_annotated_frame"] is None:
                # If no frame, send a placeholder or just wait
                time.sleep(0.1)
                continue
            
            frame = STATE["shared_state"]["latest_annotated_frame"].copy()

        # Encode frame as JPEG
        (flag, encodedImage) = cv2.imencode(".jpg", frame)
        if not flag:
            continue

        # Yield the frame in the multipart content format
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + bytearray(encodedImage) + b'\r\n')

@app.route('/video_feed')
def video_feed():
    # Return the response generated by the frame generator
    return Response(generate_frames(),
                    mimetype="multipart/x-mixed-replace; boundary=frame")

if __name__ == '__main__':
    if not all([config.EMAIL_SENDER, config.EMAIL_PASSWORD, config.EMAIL_RECEIVER, config.GEMINI_API_KEY]):
        print("="*50)
        print("‚ö†Ô∏è WARNING: Missing one or more environment variables from .env")
        print("Email sending and/or Gemini inference may fail.")
        print("Please check your .env file.")
        print("="*50)
    
    # Run Flask app on port 5000
    app.run(host="0.0.0.0", port=5000, debug=True, use_reloader=False)